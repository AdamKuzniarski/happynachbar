generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum UserRole {
  USER
  MODERATOR
  ADMIN
}

model User {
  id                String       @id @default(uuid()) @db.Uuid
  email             String       @unique
  passwordHash      String
  lastActiveAt      DateTime?
  profile           UserProfile?
  createdActivities Activity[]


  role UserRole @default(USER)

  isBanned Boolean @default(false)
  bannedAt DateTime?
  banReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  warningsReceived UserWarning[] @relation("WarningsReceived")
  warningsCreated UserWarning[] @relation("WarningsCreatedBy")
  auditLogs AuditLog[] @relation("AuditLogsByActor")

}

model UserProfile {
  userId String @id @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  plz String?

  displayName String @default("Neighbor") 
  avatarUrl String?
  bio String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([plz])
}

enum ActivityStatus {
  ACTIVE
  ARCHIVED
}

enum ActivityCategory {
  OUTDOOR
  SOCIAL
  SPORT
  INDOOR
  HELP
  OTHER
}

model Activity {
  id          String           @id @default(uuid()) @db.Uuid
  title       String
  description String?
  category    ActivityCategory
  status      ActivityStatus   @default(ACTIVE)

  // Fur Feed-Filterung (plz optional in Query, aber am Activity-Datensatz wird required)

  plz String @db.VarChar(5)

  // Optional für RealTime zu arbeiten

  scheduledAt DateTime?

  // Owner / Creator (für favorites und die Rechte)
  createdById String @db.Uuid
  createdBy   User   @relation(fields: [createdById], references: [id], onDelete: Restrict)

  images ActivityImage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // "Listing(createdAt, plz, status, category)" - für Filter u. Sort-Optionen
  @@index([plz, status, category, createdAt])
  @@index([createdAt])
}

model ActivityImage {
  id         String   @id @default(uuid()) @db.Uuid
  activityId String   @db.Uuid
  activity   Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)

  url       String
  sortOrder Int     @default(0)
  alt       String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([activityId, sortOrder]) // Innerhalb einer Activity darf keinen zweiten Datensatz mit selben sortOrder geben 
  @@index([activityId])
}

enum WarningSeverity {
  LOW
  MEDIUM
  HIGH
}

model UserWarning {

  id String @id @default(uuid()) @db.Uuid
  userId String @db.Uuid
  user User @relation("WarningsReceived", fields: [userId], references: [id], onDelete: Cascade)

  message String
  severity WarningSeverity @default(LOW)
  expiresAt DateTime?

  createdByAdminId String @db.Uuid
  createdByAdmin User @relation("WarningsCreatedBy", fields: [createdByAdminId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([createdByAdminId, createdAt])
}

model AuditLog {
  id String @id @default(uuid()) @db.Uuid

  actorUserId String? @db.Uuid
  actorUser User? @relation("AuditLogsByActor", fields: [actorUserId], references: [id], onDelete: SetNull)

  action String
  entityType String
  entityId String
  metadata Json?

  createdAt DateTime @default(now())

  @@index([entityType, entityId, createdAt])
  @@index([actorUserId, createdAt])
}